# interview
哈希表
实现：发布一个内存空间作为hashmap存储空间大小为N，hash-key为对象的hash值取模N得到k。放入存储空间
如果空间发生冲突，就在这个空间之上建立链表存储这个物体。访问时用hash-key访问，当出现有多个链路时便利这个链表。哈希空间太小会访问过慢。太大又浪费空间。

==和equal区别
==用于比较基本数据类型。equal用来比较类。（一般重写）不重写的话和==一样比较类的地址。（基本数据类型没有地址这一情况）

引用传递和值传递
值传递是传递变量的一个副本。操作不对原变量有影响。
引用传递给地址，操作会有影响

多线程
实现：继承thread和实现runnable
重写run方法。start启动线程
区别：继承了thread类不能继承其他类。接口可以多实现。创建对象时实现了runnable接口的对象必须丢到thread的构造方法里面。

线程池
在开发中，频繁的创建和销毁一个线程，是很耗资源的，为此找出了一个可以循环利用已经存在的线程来达到自己的目的，线程池顾名思义，也就是线程池的集合，通过线程池执行的线程任务，可以很有效的去规划线程的使用。
newSingleThreadPool 单线程池，只能执行一个线程，执行完成执行下一个，有点像队列
newFixedThreadPool 固定长度线程池，每当提交一个任务时就创建一个线程池，直到达到线程池的最大数量，这时线程池的规模将不再变化。
newCacheThreadPool (推荐使用)可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。
newScheduledThreadPool 延迟任务的固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。
拿newCacheThreadPool来说，每次submit一个线程进去都会进行执行，执行完成自动填充下一个任务。
例子：开一堆线程来计算斐波那契数列前30个：
![image](https://github.com/272437543/interview/blob/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%93%E6%9E%9C.png)
当线程1执行完成后，马上线程池又给它按排上了新的线程（第二行和第五行）

tcp/ip 三次握手 四次挥手 模型

http的应用

get 

post 

http报文 

常用状态码

json

b+树 （检索文件）


算法题：
栈的最大值
入栈时设定最大值，遇到比当前值大的值就更新，并push当前值减去最大值
出栈时pop的值加上最大值，如果pop值为正，相加后将最大值减去这个pop出的值。

斐波那契数列
（1 1 2 3 5 8 13）
实现：递归和非递归
特殊法：矩阵相乘o（logn）公式法o（1）
前n项和Sn=a（n+2）-1

合并两个有序数组（时间复杂度O(M + N)）

